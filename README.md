# ActivityElement

> A small Web Component framework for creating web apps using a workflow-first
> and user-centric approach. The goal is to work at a higher abstraction layer
> than *Components* but low enough to use the programming language directly
> rather than, as with
> [ZjsComponent](https://github.com/lelanthran/ZjsComponent), a declarative
> process.

> Note that all the documentation (including this) was autogenerated by one or
> more LLMs. The code, however, is all mine.


**ActivityElement** transforms how you build modular web applications by
allowing you to dynamically load and manage remote activities
(mini-applications) with a simple intent-based API. Perfect for
micro-frontends, plugin systems, and modular app architectures.

## 🚀 Quick Start

### 1. Register an Activity
```javascript
// Register a remote calculator activity
ActivityElement.registerIntent('calculator', 'https://myapp.com/activities/calculator.actv');
```

### 2. Launch the Activity
```javascript
// Launch with parameters and get a promise-based result
const activity = await ActivityElement.intentStart('calculator', { 
  initialValue: 100 
});

// Wait for user to complete the calculation
const result = await activity.result;
console.log('User calculated:', result.value); // { answer: 250 }
```

### 3. Create a Remote Activity
```html
<!-- calculator.actv -->
<div class="calculator">
  <input id="display" type="number" value="0">
  <button onclick="addTen()">+10</button>
  <button onclick="finish()">Done</button>
</div>

<script>
exports.onCreate = (activity, params) => {
  document.getElementById('display').value = params.initialValue || 0;
};

function addTen() {
  const display = document.getElementById('display');
  display.value = parseInt(display.value) + 10;
}

function finish() {
  const answer = parseInt(document.getElementById('display').value);
  activity.finish({ answer }); // Resolves the promise with the result
}
</script>
```

That's it! The activity loads remotely, runs in your page, and returns results seamlessly.

## ✨ Why ActivityElement?

### Traditional Approach Problems
```javascript
// ❌ Tightly coupled components
import Calculator from './components/Calculator';
import UserProfile from './components/UserProfile';
import PaymentForm from './components/PaymentForm';

// ❌ Large bundle sizes
// ❌ All components loaded upfront
// ❌ Hard to update individual features
// ❌ No isolation between components
```

### ActivityElement Solution
```javascript
// ✅ Register once, use anywhere
ActivityElement.registerIntent('calculator', '/activities/calc.actv');
ActivityElement.registerIntent('profile', '/activities/profile.actv');
ActivityElement.registerIntent('payment', '/activities/payment.actv');

// ✅ Load on demand
const calc = await ActivityElement.intentStart('calculator');

// ✅ Each activity is isolated and can be updated independently
// ✅ Smaller initial bundle size
// ✅ Perfect for micro-frontends
```

## 🎯 Core Features

- **🔌 Plugin Architecture**: Load activities dynamically from remote sources
- **📱 Intent-Based Routing**: Launch activities by name, not URL
- **🔄 Promise-Based API**: Async/await support with proper lifecycle management
- **❌ Cancellation Support**: Built-in cancellation with cleanup handlers
- **🧹 Automatic Cleanup**: Memory and DOM cleanup when activities complete
- **🔒 Isolated Execution**: Each activity runs in its own context
- **📦 Zero Dependencies**: Pure Web Components, works with any framework

## 💡 Use Cases

### Micro-Frontend Architecture
```javascript
// Different teams can own different activities
ActivityElement.registerIntent('checkout', 'https://payments.myapp.com/checkout.actv');
ActivityElement.registerIntent('analytics', 'https://analytics.myapp.com/dashboard.actv');
ActivityElement.registerIntent('support', 'https://support.myapp.com/chat.actv');

// Launch activities from different domains seamlessly
const checkout = await ActivityElement.intentStart('checkout', { 
  items: cartItems, 
  total: 99.99 
});
```

### Plugin System
```javascript
// Load user-installed plugins
const plugins = await fetchUserPlugins();
plugins.forEach(plugin => {
  ActivityElement.registerIntent(plugin.name, plugin.url);
});

// User can now activate any plugin
const pluginResult = await ActivityElement.intentStart('user-plugin-name');
```

### Modal/Dialog Management
```javascript
// Replace complex modal libraries
const userChoice = await ActivityElement.intentStart('confirmation-dialog', {
  title: 'Delete Item',
  message: 'Are you sure you want to delete this item?',
  buttons: ['Cancel', 'Delete']
});

if (userChoice.value === 'Delete') {
  deleteItem();
}
```

### A/B Testing & Feature Flags
```javascript
// Dynamically load different versions
const variant = getABTestVariant();
ActivityElement.registerIntent('signup-form', `/activities/signup-${variant}.actv`);

const signupResult = await ActivityElement.intentStart('signup-form');
```

## 📋 Real-World Example

Here's a complete example of a task management system using ActivityElement:

```javascript
// App initialization
ActivityElement.registerIntent('task-list', '/activities/task-list.actv');
ActivityElement.registerIntent('task-editor', '/activities/task-editor.actv');
ActivityElement.registerIntent('settings', '/activities/settings.actv');

// Main app logic
class TaskApp {
  async showTasks() {
    const taskList = await ActivityElement.intentStart('task-list');
    const result = await taskList.result;
    
    if (result.status === 'completed' && result.value.action === 'edit') {
      return this.editTask(result.value.taskId);
    }
  }
  
  async editTask(taskId) {
    const editor = await ActivityElement.intentStart('task-editor', { taskId });
    const result = await editor.result;
    
    if (result.status === 'completed') {
      // Task was updated, refresh the list
      return this.showTasks();
    }
  }
  
  async openSettings() {
    const settings = await ActivityElement.intentStart('settings');
    // Settings activity handles its own lifecycle
  }
}
```

## 🛠 Installation: Copy & Paste
The entire implementation is in a single file - just copy the
`ActivityElement` class into your project.

## 📚 API Overview

### Registration
```javascript
ActivityElement.registerIntent(intentName, remoteSrc)
```

### Launching
```javascript
const activity = await ActivityElement.intentStart(intentName, params, options)
const result = await activity.result
```

### Activity Lifecycle (in remote activities)
```javascript
// Complete successfully
activity.finish(returnValue)

// Cancel with reason
activity.cancel('user cancelled')

// Fail with error
activity.fail(new Error('something went wrong'))

// Handle cancellation
activity.onCancel(reason => cleanup())
```

## 🔧 Creating Activities

Activities are simple HTML files with embedded JavaScript:

```html
<!-- my-activity.actv -->
<div class="my-ui">
  <h1>Hello from Activity!</h1>
  <button onclick="complete()">Finish</button>
</div>

<script>
// Called when activity loads
exports.onCreate = (activity, params) => {
  console.log('Activity started with:', params);
};

// Called when activity is destroyed
exports.onDestroy = (activity) => {
  console.log('Cleaning up...');
};

function complete() {
  activity.finish({ success: true });
}
</script>
```

## 🌟 Advanced Features

### Cancellation Handling
```javascript
const longTask = await ActivityElement.intentStart('data-processing', { 
  dataset: largeDataset 
});

// Cancel after 30 seconds
setTimeout(() => longTask.cancel('timeout'), 30000);

const result = await longTask.result;
if (result.status === 'cancelled') {
  console.log('Task was cancelled:', result.reason);
}
```

### Custom Containers
```javascript
const modal = document.getElementById('modal-container');
const activity = await ActivityElement.intentStart('user-form', {}, { 
  container: modal 
});
```

### Error Handling
```javascript
try {
  const activity = await ActivityElement.intentStart('risky-activity');
  const result = await activity.result;
} catch (error) {
  console.error('Activity failed:', error);
}
```


